const CronJob = require('cron').CronJob;
const fetch = require("node-fetch");
const FormData = require('form-data');
const fs = require('fs');

var job = new CronJob('*/30 * * * * *', function() {

    var fs = require('fs');
    var Promise = require('bluebird');
    var readFile = Promise.promisify(fs.readFile);
    var writeFile = Promise.promisify(fs.writeFile);

    var promiseArray = [
                        //readFile('Conduit Inventory.txt'), 
                        //readFile('Conduit statistics.txt'),
                        readFile('sample/summary/Flow routing continuity.txt'),
                        readFile('sample/summary/Inflows.txt'),
                        //readFile('Model complexity.txt'),
                        //readFile('Model inventory.txt'),
                        //readFile('Node statistics.txt'),
                        //readFile('Options.txt'),
                        //readFile('Pipe inventory.txt'),
                        readFile('sample/summary/Results statistics.txt'),
                        readFile('sample/summary/Runoff quantity continuity.txt'),
                        //readFile('Subcatchment statistics.txt'),
                        //readFile('Unused objects.txt')
                    ];

    let data_dict = {
        "Dry weather inflow (MG)": "dryweaflow",
        "Wet weather inflow (MG)": "wetweaflow",
        "Groundwater inflow (MG)": "groundweaflow",
        "RDII inflow (MG)": "rdiiflow",
        "External inflow (MG)": "exnalflow",
        "External outflow (MG)": "exnaloutflow",
        "Flooding loss (MG)": "floodloss",
        "Evaporation loss (MG)": "evaloss",
        "Exfiltration loss (MG": "exfiltionloss",
        "Initial stored volume (MG)": "lnitialvols",
        "Final stored volume (MG)": "finalvols",
        "Continuity error (%)": "conerrors",
        "Time series inflows": "timeflows",
        "Dry weather inflows": "dryweaflows",
        "Groundwater inflows": "groundflows",
        "Max. subcatchment total runoff (MG)": "maxmg",
        "Max. subcatchment peak runoff (cfs)": "maxcfs",
        "Max. subcatchment runoff coefficient": "maxcoeffnt",
        "Max. subcatchment total precip (in)": "maxin",
        "Min. subcatchment total precip (in)": "minin",
        "Max. node depth (ft)": "mxnode",
        "Num. nodes surcharged": "surcharged",
        "Max. node surcharge duration (hours)": "nodesurched",
        "Max. node height above crown (ft)": "maxcrown",
        "Min. node depth below rim (ft)": "minbelow",
        "Num. nodes flooded": "flooded",
        "Max. node flooding duration (hours)": "flooding",
        "Max. node flood volume (MG)": "floodmg",
        "Max. node ponded volume or depth (acre-in/1000 ft?/ft)": "pondedvolume",
        "Max. storage volume (1000 ft?)": "maxvolume",
        "Max. storage percent full (%)": "maxperfull",
        "Max. outfall flow frequency (%)": "maxfrecy",
        "Max. outfall peak flow (cfs)": "results_maxflow",
        "Max. outfall total volume (MG)": "maxoutfallmg",
        "Total outfall volume (MG)": "totalmg",
        "Max. link peak flow (cfs)": "maxpeak",
        "Max. link peak velocity (ft/s)": "maxlinkty",
        "Min. link peak velocity (ft/s)": "minpeakty",
        "Num. conduits surcharged": "conduits",
        "Max. conduit surcharge duration (hours)": "maxconduits",
        "Max. conduit capacity limited duration (hours)": "maxcapacity",
        "Initial LID storage (in)": "lidstroage",
        "Initial snow cover (in)": "snowcover",
        "Total precipitation (in)": "totalin",
        "Outfall runon (in)": "runonin",
        "Evaporation loss (in)": "evalossin",
        "Infiltration loss (in)": "infitionloss",
        "Surface runoff (in)": "surfacein",
        "LID drainage (in)": "drainage",
        "Snow removed (in)": "snowved",
        "Final snow cover (in)": "finalsnow",
        "Final storage (in)": "finalin",
        "Continuity error (%)": "conerror",
    };

    Promise.all(promiseArray).then((dataArray)=>{
        var data = '';
        const obj ={};
        for(var i=0;i<dataArray.length;i++){
            data += dataArray[i];
            //dataArray ไม่ใช่ row แต่เป็นไฟล์
            let allfile = ""+dataArray[i];
            //eval(dataArray[i]);
            //console.log(eval(dataArray[i]));
            
            //let column = allfile.split("\t");
            let breakfile = allfile.split("\r\n");
            for(item of breakfile){
                let line = item.split("\t");
                if(line.length>=2){
                    let key = ""+line[0];
                    let value = ""+line[1];
                    let new_key = data_dict[key];
                    obj[new_key] = value;
                }
                //console.log(line);
            }
            //let file = breakfile.toString().split(",");
            //console.log(breakfile);
        }
        console.log(obj);

        //------scraping-------
        /*var osmosis = require('osmosis');

        osmosis
            .get('sample/test1.html')
            .find('table.desc')
            .set('data')
            .data(function(res) {
                console.log(res)
             })
            .log(console.log)
            .error(console.log)
            .debug(console.log)
        */

        var reportgen = '';
        fs.readFile('sample/test1.html', (err, data) => {
            if (err) throw err;
            data = ''+data;
            data = data.split("<td>");
            data = data[6];
            data = data.split("<");
            data = data[0];
            //console.log('data',data);
            reportgen += data;
            console.log(reportgen);

            //-------------------------fetch file-----------------------
            var form = new FormData();
            //form.append('my_field', 'my value');
            //form.append('my_buffer', new Buffer(10));
            form.append('Outfalls', fs.createReadStream('sample/graph/Rainfall_Runoff.png'));
            form.append('kmls', fs.createReadStream('sample/kml/2D_Base.kmz'));
            form.append('profiles', fs.createReadStream('sample/profile/ซอยรามคำแหง 1-5.png'));
            form.append('profiles2', fs.createReadStream('sample/profile/แยกพัฒนาการ LH.png'));
            form.append('profiles3', fs.createReadStream('sample/profile/แยกพัฒนาการ RH.png'));
            form.append('profiles4', fs.createReadStream('sample/profile/แยกลำสาลี RL.png'));
            form.append('profiles5', fs.createReadStream('sample/profile/หน้ามหาวิยาลัยรามคำแหง (ฝั่งมหาวิทยาลัย).png'));
            form.append('detail', JSON.stringify(obj));
            form.append('report_generate', data);
            console.log("Before fetch");

            /*
            form.submit('http://example.org/', function(err, res) {
                // res – response object (http.IncomingMessage)  //
                res.resume();
            });
            */

            const rawResponse = fetch('https://weather.ckartisan.com/api/weatherapi', {
                method: 'POST',
                /*headers: {
                    'Accept': 'application/json',
                    'Content-Type': 'application/json'
                },*/
                body: form
            })
            .then((response) => response.json())
            .then((result) => {
                console.log('Success:', result);
            })
            .catch((error) => {
                console.error('Error:', error);
            });
            //const answer = rawResponse.json();

            //console.log(obj);
            //console.log(typeof(data));

        });
        

    });
    
    /*Promise.all(promiseArray).then((dataArray)=>{
        var data = '';
        for(var i=0;i<dataArray.length;i++){
            data += dataArray[i];
            //dataArray ไม่ใช่ row แต่เป็นไฟล์
            let allfile = ""+dataArray[i];
            //eval(dataArray[i]);
            //console.log(eval(dataArray[i]));
            let column = allfile.split("\t");
            let breakfile = column.toString().split("\r\n");
            let file = breakfile.toString().split(",");
            console.log(file);
        }
    //console.log(typeof(data));
    });*/

}, null, true, 'America/Los_Angeles');
job.start();